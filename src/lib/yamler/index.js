var parseCst=require("./sctparse.js"),Document$1=require("./jdoc.js"),Schema=require("./sch.js"),PlainValue=require("./pval.js"),warnings=require("./warns.js");function createNode(e,n=!0,t){void 0===t&&"string"==typeof n&&(t=n,n=!0);const s=Object.assign({},Document$1.Document.defaults[Document$1.defaultOptions.version],Document$1.defaultOptions);return new Schema.Schema(s).createNode(e,n,t)}require("./seqres.js");class Document extends Document$1.Document{constructor(e){super(Object.assign({},Document$1.defaultOptions,e))}}function parseAllDocuments(e,n){const t=[];let s;for(const r of parseCst.parse(e)){const e=new Document(n);e.parse(r,s),t.push(e),s=e}return t}function parseDocument(e,n){const t=parseCst.parse(e),s=new Document(n).parse(t[0]);if(t.length>1){const e="Source contains multiple documents; please use YAML.parseAllDocuments()";s.errors.unshift(new PlainValue.YAMLSemanticError(t[1],e))}return s}function parse(e,n){const t=parseDocument(e,n);if(t.warnings.forEach((e=>warnings.warn(e))),t.errors.length>0)throw t.errors[0];return t.toJSON()}function stringify(e,n){const t=new Document(n);return t.contents=e,String(t)}const YAMLER={createNode:createNode,defaultOptions:Document$1.defaultOptions,Document:Document,parse:parse,parseAllDocuments:parseAllDocuments,parseCST:parseCst.parse,parseDocument:parseDocument,scalarOptions:Document$1.scalarOptions,stringify:stringify};module.exports=YAMLER;
