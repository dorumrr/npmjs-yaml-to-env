var PlainValue=require("./pval.js"),resolveSeq=require("./seqres.js"),Schema=require("./sch.js");const defaultOptions={anchorPrefix:"a",customTags:null,indent:2,indentSeq:!0,keepCstNodes:!1,keepNodeTypes:!0,keepBlobsInJSON:!0,mapAsMap:!1,maxAliasCount:100,prettyErrors:!1,simpleKeys:!1,version:"1.2"},scalarOptions={get binary(){return resolveSeq.binaryOptions},set binary(e){Object.assign(resolveSeq.binaryOptions,e)},get bool(){return resolveSeq.boolOptions},set bool(e){Object.assign(resolveSeq.boolOptions,e)},get int(){return resolveSeq.intOptions},set int(e){Object.assign(resolveSeq.intOptions,e)},get null(){return resolveSeq.nullOptions},set null(e){Object.assign(resolveSeq.nullOptions,e)},get str(){return resolveSeq.strOptions},set str(e){Object.assign(resolveSeq.strOptions,e)}},documentOptions={"1.0":{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:PlainValue.defaultTagPrefix},{handle:"!!",prefix:"tag:private.yaml.org,2002:"}]},1.1:{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:PlainValue.defaultTagPrefix}]},1.2:{schema:"core",merge:!1,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:PlainValue.defaultTagPrefix}]}};function stringifyTag(e,t){if("1.0"===(e.version||e.options.version)){const e=t.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);if(e)return"!"+e[1];const s=t.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);return s?`!${s[1]}/${s[2]}`:`!${t.replace(/^tag:/,"")}`}let s=e.tagPrefixes.find((e=>0===t.indexOf(e.prefix)));if(!s){const n=e.getDefaults().tagPrefixes;s=n&&n.find((e=>0===t.indexOf(e.prefix)))}if(!s)return"!"===t[0]?t:`!<${t}>`;const n=t.substr(s.prefix.length).replace(/[!,[\]{}]/g,(e=>({"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"}[e])));return s.handle+n}function getTagObject(e,t){if(t instanceof resolveSeq.Alias)return resolveSeq.Alias;if(t.tag){const s=e.filter((e=>e.tag===t.tag));if(s.length>0)return s.find((e=>e.format===t.format))||s[0]}let s,n;if(t instanceof resolveSeq.Scalar){n=t.value;const o=e.filter((e=>e.identify&&e.identify(n)||e.class&&n instanceof e.class));s=o.find((e=>e.format===t.format))||o.find((e=>!e.format))}else n=t,s=e.find((e=>e.nodeClass&&n instanceof e.nodeClass));if(!s){const e=n&&n.constructor?n.constructor.name:typeof n;throw new Error(`Tag not resolved for ${e} value`)}return s}function stringifyProps(e,t,{anchors:s,doc:n}){const o=[],r=n.anchors.getName(e);return r&&(s[r]=e,o.push(`&${r}`)),e.tag?o.push(stringifyTag(n,e.tag)):t.default||o.push(stringifyTag(n,t.tag)),o.join(" ")}function stringify(e,t,s,n){const{anchors:o,schema:r}=t.doc;let i;if(!(e instanceof resolveSeq.Node)){const t={aliasNodes:[],onTagObj:e=>i=e,prevObjects:new Map};e=r.createNode(e,!0,null,t);for(const e of t.aliasNodes){e.source=e.source.node;let t=o.getName(e.source);t||(t=o.newName(),o.map[t]=e.source)}}if(e instanceof resolveSeq.Pair)return e.toString(t,s,n);i||(i=getTagObject(r.tags,e));const a=stringifyProps(e,i,t);a.length>0&&(t.indentAtStart=(t.indentAtStart||0)+a.length+1);const c="function"==typeof i.stringify?i.stringify(e,t,s,n):e instanceof resolveSeq.Scalar?resolveSeq.stringifyString(e,t,s,n):e.toString(t,s,n);return a?e instanceof resolveSeq.Scalar||"{"===c[0]||"["===c[0]?`${a} ${c}`:`${a}\n${t.indent}${c}`:c}class Anchors{static validAnchorNode(e){return e instanceof resolveSeq.Scalar||e instanceof resolveSeq.YAMLSeq||e instanceof resolveSeq.YAMLMap}constructor(e){PlainValue._defineProperty(this,"map",Object.create(null)),this.prefix=e}createAlias(e,t){return this.setAnchor(e,t),new resolveSeq.Alias(e)}createMergePair(...e){const t=new resolveSeq.Merge;return t.value.items=e.map((e=>{if(e instanceof resolveSeq.Alias){if(e.source instanceof resolveSeq.YAMLMap)return e}else if(e instanceof resolveSeq.YAMLMap)return this.createAlias(e);throw new Error("Merge sources must be Map nodes or their Aliases")})),t}getName(e){const{map:t}=this;return Object.keys(t).find((s=>t[s]===e))}getNames(){return Object.keys(this.map)}getNode(e){return this.map[e]}newName(e){e||(e=this.prefix);const t=Object.keys(this.map);for(let s=1;;++s){const n=`${e}${s}`;if(!t.includes(n))return n}}resolveNodes(){const{map:e,_cstAliases:t}=this;Object.keys(e).forEach((t=>{e[t]=e[t].resolved})),t.forEach((e=>{e.source=e.source.resolved})),delete this._cstAliases}setAnchor(e,t){if(null!=e&&!Anchors.validAnchorNode(e))throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");if(t&&/[\x00-\x19\s,[\]{}]/.test(t))throw new Error("Anchor names must not contain whitespace or control characters");const{map:s}=this,n=e&&Object.keys(s).find((t=>s[t]===e));if(n){if(!t)return n;n!==t&&(delete s[n],s[t]=e)}else{if(!t){if(!e)return null;t=this.newName()}s[t]=e}return t}}const visit=(e,t)=>{if(e&&"object"==typeof e){const{tag:s}=e;e instanceof resolveSeq.Collection?(s&&(t[s]=!0),e.items.forEach((e=>visit(e,t)))):e instanceof resolveSeq.Pair?(visit(e.key,t),visit(e.value,t)):e instanceof resolveSeq.Scalar&&s&&(t[s]=!0)}return t},listTagNames=e=>Object.keys(visit(e,{}));function parseContents(e,t){const s={before:[],after:[]};let n,o=!1;for(const r of t)if(r.valueRange){if(void 0!==n){const t="Document contains trailing content not separated by a ... or --- line";e.errors.push(new PlainValue.YAMLSyntaxError(r,t));break}const t=resolveSeq.resolveNode(e,r);o&&(t.spaceBefore=!0,o=!1),n=t}else if(null!==r.comment){(void 0===n?s.before:s.after).push(r.comment)}else r.type===PlainValue.Type.BLANK_LINE&&(o=!0,void 0===n&&s.before.length>0&&!e.commentBefore&&(e.commentBefore=s.before.join("\n"),s.before=[]));if(e.contents=n||null,n){const t=s.before.join("\n");if(t){const e=n instanceof resolveSeq.Collection&&n.items[0]?n.items[0]:n;e.commentBefore=e.commentBefore?`${t}\n${e.commentBefore}`:t}e.comment=s.after.join("\n")||null}else e.comment=s.before.concat(s.after).join("\n")||null}function resolveTagDirective({tagPrefixes:e},t){const[s,n]=t.parameters;if(!s||!n){const e="Insufficient parameters given for %TAG directive";throw new PlainValue.YAMLSemanticError(t,e)}if(e.some((e=>e.handle===s))){const e="The %TAG directive must only be given at most once per handle in the same document.";throw new PlainValue.YAMLSemanticError(t,e)}return{handle:s,prefix:n}}function resolveYamlDirective(e,t){let[s]=t.parameters;if("YAML:1.0"===t.name&&(s="1.0"),!s){const e="Insufficient parameters given for %YAML directive";throw new PlainValue.YAMLSemanticError(t,e)}if(!documentOptions[s]){const n=`Document will be parsed as YAML ${e.version||e.options.version} rather than YAML ${s}`;e.warnings.push(new PlainValue.YAMLWarning(t,n))}return s}function parseDirectives(e,t,s){const n=[];let o=!1;for(const s of t){const{comment:t,name:r}=s;switch(r){case"TAG":try{e.tagPrefixes.push(resolveTagDirective(e,s))}catch(t){e.errors.push(t)}o=!0;break;case"YAML":case"YAML:1.0":if(e.version){const t="The %YAML directive must only be given at most once per document.";e.errors.push(new PlainValue.YAMLSemanticError(s,t))}try{e.version=resolveYamlDirective(e,s)}catch(t){e.errors.push(t)}o=!0;break;default:if(r){const t=`YAML only supports %TAG and %YAML directives, and not %${r}`;e.warnings.push(new PlainValue.YAMLWarning(s,t))}}t&&n.push(t)}if(s&&!o&&"1.1"===(e.version||s.version||e.options.version)){const t=({handle:e,prefix:t})=>({handle:e,prefix:t});e.tagPrefixes=s.tagPrefixes.map(t),e.version=s.version}e.commentBefore=n.join("\n")||null}function assertCollection(e){if(e instanceof resolveSeq.Collection)return!0;throw new Error("Expected a YAML collection as document contents")}class Document{constructor(e){this.anchors=new Anchors(e.anchorPrefix),this.commentBefore=null,this.comment=null,this.contents=null,this.directivesEndMarker=null,this.errors=[],this.options=e,this.schema=null,this.tagPrefixes=[],this.version=null,this.warnings=[]}add(e){return assertCollection(this.contents),this.contents.add(e)}addIn(e,t){assertCollection(this.contents),this.contents.addIn(e,t)}delete(e){return assertCollection(this.contents),this.contents.delete(e)}deleteIn(e){return resolveSeq.isEmptyPath(e)?null!=this.contents&&(this.contents=null,!0):(assertCollection(this.contents),this.contents.deleteIn(e))}getDefaults(){return Document.defaults[this.version]||Document.defaults[this.options.version]||{}}get(e,t){return this.contents instanceof resolveSeq.Collection?this.contents.get(e,t):void 0}getIn(e,t){return resolveSeq.isEmptyPath(e)?!t&&this.contents instanceof resolveSeq.Scalar?this.contents.value:this.contents:this.contents instanceof resolveSeq.Collection?this.contents.getIn(e,t):void 0}has(e){return this.contents instanceof resolveSeq.Collection&&this.contents.has(e)}hasIn(e){return resolveSeq.isEmptyPath(e)?void 0!==this.contents:this.contents instanceof resolveSeq.Collection&&this.contents.hasIn(e)}set(e,t){assertCollection(this.contents),this.contents.set(e,t)}setIn(e,t){resolveSeq.isEmptyPath(e)?this.contents=t:(assertCollection(this.contents),this.contents.setIn(e,t))}setSchema(e,t){if(!e&&!t&&this.schema)return;"number"==typeof e&&(e=e.toFixed(1)),"1.0"===e||"1.1"===e||"1.2"===e?(this.version?this.version=e:this.options.version=e,delete this.options.schema):e&&"string"==typeof e&&(this.options.schema=e),Array.isArray(t)&&(this.options.customTags=t);const s=Object.assign({},this.getDefaults(),this.options);this.schema=new Schema.Schema(s)}parse(e,t){this.options.keepCstNodes&&(this.cstNode=e),this.options.keepNodeTypes&&(this.type="DOCUMENT");const{directives:s=[],contents:n=[],directivesEndMarker:o,error:r,valueRange:i}=e;if(r&&(r.source||(r.source=this),this.errors.push(r)),parseDirectives(this,s,t),o&&(this.directivesEndMarker=!0),this.range=i?[i.start,i.end]:null,this.setSchema(),this.anchors._cstAliases=[],parseContents(this,n),this.anchors.resolveNodes(),this.options.prettyErrors){for(const e of this.errors)e instanceof PlainValue.YAMLError&&e.makePretty();for(const e of this.warnings)e instanceof PlainValue.YAMLError&&e.makePretty()}return this}listNonDefaultTags(){return(e=this.contents,Object.keys(visit(e,{}))).filter((e=>0!==e.indexOf(Schema.Schema.defaultPrefix)));var e}setTagPrefix(e,t){if("!"!==e[0]||"!"!==e[e.length-1])throw new Error("Handle must start and end with !");if(t){const s=this.tagPrefixes.find((t=>t.handle===e));s?s.prefix=t:this.tagPrefixes.push({handle:e,prefix:t})}else this.tagPrefixes=this.tagPrefixes.filter((t=>t.handle!==e))}toJSON(e,t){const{keepBlobsInJSON:s,mapAsMap:n,maxAliasCount:o}=this.options,r=s&&("string"!=typeof e||!(this.contents instanceof resolveSeq.Scalar)),i={doc:this,indentStep:"  ",keep:r,mapAsMap:r&&!!n,maxAliasCount:o,stringify:stringify},a=Object.keys(this.anchors.map);a.length>0&&(i.anchors=new Map(a.map((e=>[this.anchors.map[e],{alias:[],aliasCount:0,count:1}]))));const c=resolveSeq.toJSON(this.contents,e,i);if("function"==typeof t&&i.anchors)for(const{count:e,res:s}of i.anchors.values())t(s,e);return c}toString(){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");const e=this.options.indent;if(!Number.isInteger(e)||e<=0){const t=JSON.stringify(e);throw new Error(`"indent" option must be a positive integer, not ${t}`)}this.setSchema();const t=[];let s=!1;if(this.version){let e="%YAML 1.2";"yaml-1.1"===this.schema.name&&("1.0"===this.version?e="%YAML:1.0":"1.1"===this.version&&(e="%YAML 1.1")),t.push(e),s=!0}const n=this.listNonDefaultTags();this.tagPrefixes.forEach((({handle:e,prefix:o})=>{n.some((e=>0===e.indexOf(o)))&&(t.push(`%TAG ${e} ${o}`),s=!0)})),(s||this.directivesEndMarker)&&t.push("---"),this.commentBefore&&(!s&&this.directivesEndMarker||t.unshift(""),t.unshift(this.commentBefore.replace(/^/gm,"#")));const o={anchors:Object.create(null),doc:this,indent:"",indentStep:" ".repeat(e),stringify:stringify};let r=!1,i=null;if(this.contents){this.contents instanceof resolveSeq.Node&&(this.contents.spaceBefore&&(s||this.directivesEndMarker)&&t.push(""),this.contents.commentBefore&&t.push(this.contents.commentBefore.replace(/^/gm,"#")),o.forceBlockIndent=!!this.comment,i=this.contents.comment);const e=i?null:()=>r=!0,n=stringify(this.contents,o,(()=>i=null),e);t.push(resolveSeq.addComment(n,"",i))}else void 0!==this.contents&&t.push(stringify(this.contents,o));return this.comment&&(r&&!i||""===t[t.length-1]||t.push(""),t.push(this.comment.replace(/^/gm,"#"))),t.join("\n")+"\n"}}PlainValue._defineProperty(Document,"defaults",documentOptions),exports.Document=Document,exports.defaultOptions=defaultOptions,exports.scalarOptions=scalarOptions;
