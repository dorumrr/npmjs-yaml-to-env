var PlainValue=require("./pval.js");function addCommentBefore(e,t,n){if(!n)return e;return`#${n.replace(/[\s\S]^/gm,`$&${t}#`)}\n${t}${e}`}function addComment(e,t,n){return n?-1===n.indexOf("\n")?`${e} #${n}`:`${e}\n`+n.replace(/^/gm,`${t||""}#`):e}class Node{}function toJSON(e,t,n){if(Array.isArray(e))return e.map(((e,t)=>toJSON(e,String(t),n)));if(e&&"function"==typeof e.toJSON){const r=n&&n.anchors&&n.anchors.get(e);r&&(n.onCreate=e=>{r.res=e,delete n.onCreate});const o=e.toJSON(t,n);return r&&n.onCreate&&n.onCreate(o),o}return n&&n.keep||"bigint"!=typeof e?e:Number(e)}class Scalar extends Node{constructor(e){super(),this.value=e}toJSON(e,t){return t&&t.keep?this.value:toJSON(this.value,e,t)}toString(){return String(this.value)}}function collectionFromPath(e,t,n){let r=n;for(let e=t.length-1;e>=0;--e){const n=t[e];if(Number.isInteger(n)&&n>=0){const e=[];e[n]=r,r=e}else{const e={};Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!0,configurable:!0}),r=e}}return e.createNode(r,!1)}const isEmptyPath=e=>null==e||"object"==typeof e&&e[Symbol.iterator]().next().done;class Collection extends Node{constructor(e){super(),PlainValue._defineProperty(this,"items",[]),this.schema=e}addIn(e,t){if(isEmptyPath(e))this.add(t);else{const[n,...r]=e,o=this.get(n,!0);if(o instanceof Collection)o.addIn(r,t);else{if(void 0!==o||!this.schema)throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);this.set(n,collectionFromPath(this.schema,r,t))}}}deleteIn([e,...t]){if(0===t.length)return this.delete(e);const n=this.get(e,!0);if(n instanceof Collection)return n.deleteIn(t);throw new Error(`Expected YAML collection at ${e}. Remaining path: ${t}`)}getIn([e,...t],n){const r=this.get(e,!0);return 0===t.length?!n&&r instanceof Scalar?r.value:r:r instanceof Collection?r.getIn(t,n):void 0}hasAllNullValues(){return this.items.every((e=>{if(!e||"PAIR"!==e.type)return!1;const t=e.value;return null==t||t instanceof Scalar&&null==t.value&&!t.commentBefore&&!t.comment&&!t.tag}))}hasIn([e,...t]){if(0===t.length)return this.has(e);const n=this.get(e,!0);return n instanceof Collection&&n.hasIn(t)}setIn([e,...t],n){if(0===t.length)this.set(e,n);else{const r=this.get(e,!0);if(r instanceof Collection)r.setIn(t,n);else{if(void 0!==r||!this.schema)throw new Error(`Expected YAML collection at ${e}. Remaining path: ${t}`);this.set(e,collectionFromPath(this.schema,t,n))}}}toJSON(){return null}toString(e,{blockItem:t,flowChars:n,isMap:r,itemIndent:o},s,a){const{indent:i,indentStep:l,stringify:c}=e,u=this.type===PlainValue.Type.FLOW_MAP||this.type===PlainValue.Type.FLOW_SEQ||e.inFlow;u&&(o+=l);const f=r&&this.hasAllNullValues();e=Object.assign({},e,{allNullValues:f,indent:o,inFlow:u,type:null});let p=!1,m=!1;const d=this.items.reduce(((t,n,r)=>{let s;n&&(!p&&n.spaceBefore&&t.push({type:"comment",str:""}),n.commentBefore&&n.commentBefore.match(/^.*$/gm).forEach((e=>{t.push({type:"comment",str:`#${e}`})})),n.comment&&(s=n.comment),u&&(!p&&n.spaceBefore||n.commentBefore||n.comment||n.key&&(n.key.commentBefore||n.key.comment)||n.value&&(n.value.commentBefore||n.value.comment))&&(m=!0)),p=!1;let a=c(n,e,(()=>s=null),(()=>p=!0));return u&&!m&&a.includes("\n")&&(m=!0),u&&r<this.items.length-1&&(a+=","),a=addComment(a,o,s),p&&(s||u)&&(p=!1),t.push({type:"item",str:a}),t}),[]);let h;if(0===d.length)h=n.start+n.end;else if(u){const{start:e,end:t}=n,r=d.map((e=>e.str));if(m||r.reduce(((e,t)=>e+t.length+2),2)>Collection.maxFlowStringSingleLineLength){h=e;for(const e of r)h+=e?`\n${l}${i}${e}`:"\n";h+=`\n${i}${t}`}else h=`${e} ${r.join(" ")} ${t}`}else{const e=d.map(t);h=e.shift();for(const t of e)h+=t?`\n${i}${t}`:"\n"}return this.comment?(h+="\n"+this.comment.replace(/^/gm,`${i}#`),s&&s()):p&&a&&a(),h}}function asItemIndex(e){let t=e instanceof Scalar?e.value:e;return t&&"string"==typeof t&&(t=Number(t)),Number.isInteger(t)&&t>=0?t:null}PlainValue._defineProperty(Collection,"maxFlowStringSingleLineLength",60);class YAMLSeq extends Collection{add(e){this.items.push(e)}delete(e){const t=asItemIndex(e);if("number"!=typeof t)return!1;return this.items.splice(t,1).length>0}get(e,t){const n=asItemIndex(e);if("number"!=typeof n)return;const r=this.items[n];return!t&&r instanceof Scalar?r.value:r}has(e){const t=asItemIndex(e);return"number"==typeof t&&t<this.items.length}set(e,t){const n=asItemIndex(e);if("number"!=typeof n)throw new Error(`Expected a valid index, not ${e}.`);this.items[n]=t}toJSON(e,t){const n=[];t&&t.onCreate&&t.onCreate(n);let r=0;for(const e of this.items)n.push(toJSON(e,String(r++),t));return n}toString(e,t,n){return e?super.toString(e,{blockItem:e=>"comment"===e.type?e.str:`- ${e.str}`,flowChars:{start:"[",end:"]"},isMap:!1,itemIndent:(e.indent||"")+"  "},t,n):JSON.stringify(this)}}const stringifyKey=(e,t,n)=>null===t?"":"object"!=typeof t?String(t):e instanceof Node&&n&&n.doc?e.toString({anchors:Object.create(null),doc:n.doc,indent:"",indentStep:n.indentStep,inFlow:!0,inStringifyKey:!0,stringify:n.stringify}):JSON.stringify(t);class Pair extends Node{constructor(e,t=null){super(),this.key=e,this.value=t,this.type=Pair.Type.PAIR}get commentBefore(){return this.key instanceof Node?this.key.commentBefore:void 0}set commentBefore(e){if(null==this.key&&(this.key=new Scalar(null)),!(this.key instanceof Node)){throw new Error("Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.")}this.key.commentBefore=e}addToJSMap(e,t){const n=toJSON(this.key,"",e);if(t instanceof Map){const r=toJSON(this.value,n,e);t.set(n,r)}else if(t instanceof Set)t.add(n);else{const r=stringifyKey(this.key,n,e),o=toJSON(this.value,r,e);r in t?Object.defineProperty(t,r,{value:o,writable:!0,enumerable:!0,configurable:!0}):t[r]=o}return t}toJSON(e,t){const n=t&&t.mapAsMap?new Map:{};return this.addToJSMap(t,n)}toString(e,t,n){if(!e||!e.doc)return JSON.stringify(this);const{indent:r,indentSeq:o,simpleKeys:s}=e.doc.options;let{key:a,value:i}=this,l=a instanceof Node&&a.comment;if(s){if(l)throw new Error("With simple keys, key nodes cannot have comments");if(a instanceof Collection){throw new Error("With simple keys, collection cannot be used as a key value")}}let c=!s&&(!a||l||(a instanceof Node?a instanceof Collection||a.type===PlainValue.Type.BLOCK_FOLDED||a.type===PlainValue.Type.BLOCK_LITERAL:"object"==typeof a));const{doc:u,indent:f,indentStep:p,stringify:m}=e;e=Object.assign({},e,{implicitKey:!c,indent:f+p});let d=!1,h=m(a,e,(()=>l=null),(()=>d=!0));if(h=addComment(h,e.indent,l),!c&&h.length>1024){if(s)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");c=!0}if(e.allNullValues&&!s)return this.comment?(h=addComment(h,e.indent,this.comment),t&&t()):d&&!l&&n&&n(),e.inFlow&&!c?h:`? ${h}`;h=c?`? ${h}\n${f}:`:`${h}:`,this.comment&&(h=addComment(h,e.indent,this.comment),t&&t());let g="",y=null;if(i instanceof Node){if(i.spaceBefore&&(g="\n"),i.commentBefore){g+=`\n${i.commentBefore.replace(/^/gm,`${e.indent}#`)}`}y=i.comment}else i&&"object"==typeof i&&(i=u.schema.createNode(i,!0));e.implicitKey=!1,!c&&!this.comment&&i instanceof Scalar&&(e.indentAtStart=h.length+1),d=!1,!o&&r>=2&&!e.inFlow&&!c&&i instanceof YAMLSeq&&i.type!==PlainValue.Type.FLOW_SEQ&&!i.tag&&!u.anchors.getName(i)&&(e.indent=e.indent.substr(2));const P=m(i,e,(()=>y=null),(()=>d=!0));let S=" ";if(g||this.comment)S=`${g}\n${e.indent}`;else if(!c&&i instanceof Collection){("["===P[0]||"{"===P[0])&&!P.includes("\n")||(S=`\n${e.indent}`)}else"\n"===P[0]&&(S="");return d&&!y&&n&&n(),addComment(h+S+P,e.indent,y)}}PlainValue._defineProperty(Pair,"Type",{PAIR:"PAIR",MERGE_PAIR:"MERGE_PAIR"});const getAliasCount=(e,t)=>{if(e instanceof Alias){const n=t.get(e.source);return n.count*n.aliasCount}if(e instanceof Collection){let n=0;for(const r of e.items){const e=getAliasCount(r,t);e>n&&(n=e)}return n}if(e instanceof Pair){const n=getAliasCount(e.key,t),r=getAliasCount(e.value,t);return Math.max(n,r)}return 1};class Alias extends Node{static stringify({range:e,source:t},{anchors:n,doc:r,implicitKey:o,inStringifyKey:s}){let a=Object.keys(n).find((e=>n[e]===t));if(!a&&s&&(a=r.anchors.getName(t)||r.anchors.newName()),a)return`*${a}${o?" ":""}`;const i=r.anchors.getName(t)?"Alias node must be after source node":"Source node not found for alias node";throw new Error(`${i} [${e}]`)}constructor(e){super(),this.source=e,this.type=PlainValue.Type.ALIAS}set tag(e){throw new Error("Alias nodes cannot have tags")}toJSON(e,t){if(!t)return toJSON(this.source,e,t);const{anchors:n,maxAliasCount:r}=t,o=n.get(this.source);if(!o||void 0===o.res){const e="This should not happen: Alias anchor was not resolved?";throw this.cstNode?new PlainValue.YAMLReferenceError(this.cstNode,e):new ReferenceError(e)}if(r>=0&&(o.count+=1,0===o.aliasCount&&(o.aliasCount=getAliasCount(this.source,n)),o.count*o.aliasCount>r)){const e="Excessive alias count indicates a resource exhaustion attack";throw this.cstNode?new PlainValue.YAMLReferenceError(this.cstNode,e):new ReferenceError(e)}return o.res}toString(e){return Alias.stringify(this,e)}}function findPair(e,t){const n=t instanceof Scalar?t.value:t;for(const r of e)if(r instanceof Pair){if(r.key===t||r.key===n)return r;if(r.key&&r.key.value===n)return r}}PlainValue._defineProperty(Alias,"default",!0);class YAMLMap extends Collection{add(e,t){e?e instanceof Pair||(e=new Pair(e.key||e,e.value)):e=new Pair(e);const n=findPair(this.items,e.key),r=this.schema&&this.schema.sortMapEntries;if(n){if(!t)throw new Error(`Key ${e.key} already set`);n.value=e.value}else if(r){const t=this.items.findIndex((t=>r(e,t)<0));-1===t?this.items.push(e):this.items.splice(t,0,e)}else this.items.push(e)}delete(e){const t=findPair(this.items,e);if(!t)return!1;return this.items.splice(this.items.indexOf(t),1).length>0}get(e,t){const n=findPair(this.items,e),r=n&&n.value;return!t&&r instanceof Scalar?r.value:r}has(e){return!!findPair(this.items,e)}set(e,t){this.add(new Pair(e,t),!0)}toJSON(e,t,n){const r=n?new n:t&&t.mapAsMap?new Map:{};t&&t.onCreate&&t.onCreate(r);for(const e of this.items)e.addToJSMap(t,r);return r}toString(e,t,n){if(!e)return JSON.stringify(this);for(const e of this.items)if(!(e instanceof Pair))throw new Error(`Map items must all be pairs; found ${JSON.stringify(e)} instead`);return super.toString(e,{blockItem:e=>e.str,flowChars:{start:"{",end:"}"},isMap:!0,itemIndent:e.indent||""},t,n)}}const MERGE_KEY="<<";class Merge extends Pair{constructor(e){if(e instanceof Pair){let t=e.value;t instanceof YAMLSeq||(t=new YAMLSeq,t.items.push(e.value),t.range=e.value.range),super(e.key,t),this.range=e.range}else super(new Scalar("<<"),new YAMLSeq);this.type=Pair.Type.MERGE_PAIR}addToJSMap(e,t){for(const{source:n}of this.value.items){if(!(n instanceof YAMLMap))throw new Error("Merge sources must be maps");const r=n.toJSON(null,e,Map);for(const[e,n]of r)t instanceof Map?t.has(e)||t.set(e,n):t instanceof Set?t.add(e):Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(t,e,{value:n,writable:!0,enumerable:!0,configurable:!0})}return t}toString(e,t){const n=this.value;if(n.items.length>1)return super.toString(e,t);this.value=n.items[0];const r=super.toString(e,t);return this.value=n,r}}const binaryOptions={defaultType:PlainValue.Type.BLOCK_LITERAL,lineWidth:76},boolOptions={trueStr:"true",falseStr:"false"},intOptions={asBigInt:!1},nullOptions={nullStr:"null"},strOptions={defaultType:PlainValue.Type.PLAIN,doubleQuoted:{jsonEncoding:!1,minMultiLineLength:40},fold:{lineWidth:80,minContentWidth:20}};function resolveScalar(e,t,n){for(const{format:n,test:r,resolve:o}of t)if(r){const t=e.match(r);if(t){let e=o.apply(null,t);return e instanceof Scalar||(e=new Scalar(e)),n&&(e.format=n),e}}return n&&(e=n(e)),new Scalar(e)}const FOLD_FLOW="flow",FOLD_BLOCK="block",FOLD_QUOTED="quoted",consumeMoreIndentedLines=(e,t)=>{let n=e[t+1];for(;" "===n||"\t"===n;){do{n=e[t+=1]}while(n&&"\n"!==n);n=e[t+1]}return t};function foldFlowLines(e,t,n,{indentAtStart:r,lineWidth:o=80,minContentWidth:s=20,onFold:a,onOverflow:i}){if(!o||o<0)return e;const l=Math.max(1+s,1+o-t.length);if(e.length<=l)return e;const c=[],u={};let f,p,m=o-t.length;"number"==typeof r&&(r>o-Math.max(2,s)?c.push(0):m=o-r);let d,h=!1,g=-1,y=-1,P=-1;for("block"===n&&(g=consumeMoreIndentedLines(e,g),-1!==g&&(m=g+l));d=e[g+=1];){if("quoted"===n&&"\\"===d){switch(y=g,e[g+1]){case"x":g+=3;break;case"u":g+=5;break;case"U":g+=9;break;default:g+=1}P=g}if("\n"===d)"block"===n&&(g=consumeMoreIndentedLines(e,g)),m=g+l,f=void 0;else{if(" "===d&&p&&" "!==p&&"\n"!==p&&"\t"!==p){const t=e[g+1];t&&" "!==t&&"\n"!==t&&"\t"!==t&&(f=g)}if(g>=m)if(f)c.push(f),m=f+l,f=void 0;else if("quoted"===n){for(;" "===p||"\t"===p;)p=d,d=e[g+=1],h=!0;const t=g>P+1?g-2:y-1;if(u[t])return e;c.push(t),u[t]=!0,m=t+l,f=void 0}else h=!0}p=d}if(h&&i&&i(),0===c.length)return e;a&&a();let S=e.slice(0,c[0]);for(let r=0;r<c.length;++r){const o=c[r],s=c[r+1]||e.length;0===o?S=`\n${t}${e.slice(0,s)}`:("quoted"===n&&u[o]&&(S+=`${e[o]}\\`),S+=`\n${t}${e.slice(o+1,s)}`)}return S}const getFoldOptions=({indentAtStart:e})=>e?Object.assign({indentAtStart:e},strOptions.fold):strOptions.fold,containsDocumentMarker=e=>/^(%|---|\.\.\.)/m.test(e);function lineLengthOverLimit(e,t,n){if(!t||t<0)return!1;const r=t-n,o=e.length;if(o<=r)return!1;for(let t=0,n=0;t<o;++t)if("\n"===e[t]){if(t-n>r)return!0;if(n=t+1,o-n<=r)return!1}return!0}function doubleQuotedString(e,t){const{implicitKey:n}=t,{jsonEncoding:r,minMultiLineLength:o}=strOptions.doubleQuoted,s=JSON.stringify(e);if(r)return s;const a=t.indent||(containsDocumentMarker(e)?"  ":"");let i="",l=0;for(let e=0,t=s[e];t;t=s[++e])if(" "===t&&"\\"===s[e+1]&&"n"===s[e+2]&&(i+=s.slice(l,e)+"\\ ",e+=1,l=e,t="\\"),"\\"===t)switch(s[e+1]){case"u":{i+=s.slice(l,e);const t=s.substr(e+2,4);switch(t){case"0000":i+="\\0";break;case"0007":i+="\\a";break;case"000b":i+="\\v";break;case"001b":i+="\\e";break;case"0085":i+="\\N";break;case"00a0":i+="\\_";break;case"2028":i+="\\L";break;case"2029":i+="\\P";break;default:"00"===t.substr(0,2)?i+="\\x"+t.substr(2):i+=s.substr(e,6)}e+=5,l=e+1}break;case"n":if(n||'"'===s[e+2]||s.length<o)e+=1;else{for(i+=s.slice(l,e)+"\n\n";"\\"===s[e+2]&&"n"===s[e+3]&&'"'!==s[e+4];)i+="\n",e+=2;i+=a," "===s[e+2]&&(i+="\\"),e+=1,l=e+1}break;default:e+=1}return i=l?i+s.slice(l):s,n?i:foldFlowLines(i,a,"quoted",getFoldOptions(t))}function singleQuotedString(e,t){if(t.implicitKey){if(/\n/.test(e))return doubleQuotedString(e,t)}else if(/[ \t]\n|\n[ \t]/.test(e))return doubleQuotedString(e,t);const n=t.indent||(containsDocumentMarker(e)?"  ":""),r="'"+e.replace(/'/g,"''").replace(/\n+/g,`$&\n${n}`)+"'";return t.implicitKey?r:foldFlowLines(r,n,"flow",getFoldOptions(t))}function blockString({comment:e,type:t,value:n},r,o,s){if(/\n[\t ]+$/.test(n)||/^\s*$/.test(n))return doubleQuotedString(n,r);const a=r.indent||(r.forceBlockIndent||containsDocumentMarker(n)?"  ":""),i=a?"2":"1",l=t!==PlainValue.Type.BLOCK_FOLDED&&(t===PlainValue.Type.BLOCK_LITERAL||!lineLengthOverLimit(n,strOptions.fold.lineWidth,a.length));let c=l?"|":">";if(!n)return c+"\n";let u="",f="";if(n=n.replace(/[\n\t ]*$/,(e=>{const t=e.indexOf("\n");return-1===t?c+="-":n!==e&&t===e.length-1||(c+="+",s&&s()),f=e.replace(/\n$/,""),""})).replace(/^[\n ]*/,(e=>{-1!==e.indexOf(" ")&&(c+=i);const t=e.match(/ +$/);return t?(u=e.slice(0,-t[0].length),t[0]):(u=e,"")})),f&&(f=f.replace(/\n+(?!\n|$)/g,`$&${a}`)),u&&(u=u.replace(/\n+/g,`$&${a}`)),e&&(c+=" #"+e.replace(/ ?[\r\n]+/g," "),o&&o()),!n)return`${c}${i}\n${a}${f}`;if(l)return n=n.replace(/\n+/g,`$&${a}`),`${c}\n${a}${u}${n}${f}`;n=n.replace(/\n+/g,"\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,`$&${a}`);const p=foldFlowLines(`${u}${n}${f}`,a,"block",strOptions.fold);return`${c}\n${a}${p}`}function plainString(e,t,n,r){const{comment:o,type:s,value:a}=e,{actualString:i,implicitKey:l,indent:c,inFlow:u}=t;if(l&&/[\n[\]{},]/.test(a)||u&&/[[\]{},]/.test(a))return doubleQuotedString(a,t);if(!a||/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(a))return l||u||-1===a.indexOf("\n")?-1!==a.indexOf('"')&&-1===a.indexOf("'")?singleQuotedString(a,t):doubleQuotedString(a,t):blockString(e,t,n,r);if(!l&&!u&&s!==PlainValue.Type.PLAIN&&-1!==a.indexOf("\n"))return blockString(e,t,n,r);if(""===c&&containsDocumentMarker(a))return t.forceBlockIndent=!0,blockString(e,t,n,r);const f=a.replace(/\n+/g,`$&\n${c}`);if(i){const{tags:e}=t.doc.schema;if("string"!=typeof resolveScalar(f,e,e.scalarFallback).value)return doubleQuotedString(a,t)}const p=l?f:foldFlowLines(f,c,"flow",getFoldOptions(t));return!o||u||-1===p.indexOf("\n")&&-1===o.indexOf("\n")?p:(n&&n(),addCommentBefore(p,c,o))}function stringifyString(e,t,n,r){const{defaultType:o}=strOptions,{implicitKey:s,inFlow:a}=t;let{type:i,value:l}=e;"string"!=typeof l&&(l=String(l),e=Object.assign({},e,{value:l}));const c=o=>{switch(o){case PlainValue.Type.BLOCK_FOLDED:case PlainValue.Type.BLOCK_LITERAL:return blockString(e,t,n,r);case PlainValue.Type.QUOTE_DOUBLE:return doubleQuotedString(l,t);case PlainValue.Type.QUOTE_SINGLE:return singleQuotedString(l,t);case PlainValue.Type.PLAIN:return plainString(e,t,n,r);default:return null}};i!==PlainValue.Type.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(l)?i=PlainValue.Type.QUOTE_DOUBLE:!s&&!a||i!==PlainValue.Type.BLOCK_FOLDED&&i!==PlainValue.Type.BLOCK_LITERAL||(i=PlainValue.Type.QUOTE_DOUBLE);let u=c(i);if(null===u&&(u=c(o),null===u))throw new Error(`Unsupported default string type ${o}`);return u}function stringifyNumber({format:e,minFractionDigits:t,tag:n,value:r}){if("bigint"==typeof r)return String(r);if(!isFinite(r))return isNaN(r)?".nan":r<0?"-.inf":".inf";let o=JSON.stringify(r);if(!e&&t&&(!n||"tag:yaml.org,2002:float"===n)&&/^\d/.test(o)){let e=o.indexOf(".");e<0&&(e=o.length,o+=".");let n=t-(o.length-e-1);for(;n-- >0;)o+="0"}return o}function checkFlowCollectionEnd(e,t){let n,r,o;switch(t.type){case PlainValue.Type.FLOW_MAP:n="}",r="flow map";break;case PlainValue.Type.FLOW_SEQ:n="]",r="flow sequence";break;default:return void e.push(new PlainValue.YAMLSemanticError(t,"Not a flow collection!?"))}for(let e=t.items.length-1;e>=0;--e){const n=t.items[e];if(!n||n.type!==PlainValue.Type.COMMENT){o=n;break}}if(o&&o.char!==n){const s=`Expected ${r} to end with ${n}`;let a;"number"==typeof o.offset?(a=new PlainValue.YAMLSemanticError(t,s),a.offset=o.offset+1):(a=new PlainValue.YAMLSemanticError(o,s),o.range&&o.range.end&&(a.offset=o.range.end-o.range.start)),e.push(a)}}function checkFlowCommentSpace(e,t){const n=t.context.src[t.range.start-1];if("\n"!==n&&"\t"!==n&&" "!==n){const n="Comments must be separated from other tokens by white space characters";e.push(new PlainValue.YAMLSemanticError(t,n))}}function getLongKeyError(e,t){const n=String(t),r=n.substr(0,8)+"..."+n.substr(-8);return new PlainValue.YAMLSemanticError(e,`The "${r}" key is too long`)}function resolveComments(e,t){for(const{afterKey:n,before:r,comment:o}of t){let t=e.items[r];t?(n&&t.value&&(t=t.value),void 0===o?!n&&t.commentBefore||(t.spaceBefore=!0):t.commentBefore?t.commentBefore+="\n"+o:t.commentBefore=o):void 0!==o&&(e.comment?e.comment+="\n"+o:e.comment=o)}}function resolveString(e,t){const n=t.strValue;return n?"string"==typeof n?n:(n.errors.forEach((n=>{n.source||(n.source=t),e.errors.push(n)})),n.str):""}function resolveTagHandle(e,t){const{handle:n,suffix:r}=t.tag;let o=e.tagPrefixes.find((e=>e.handle===n));if(!o){const r=e.getDefaults().tagPrefixes;if(r&&(o=r.find((e=>e.handle===n))),!o)throw new PlainValue.YAMLSemanticError(t,`The ${n} tag handle is non-default and was not declared.`)}if(!r)throw new PlainValue.YAMLSemanticError(t,`The ${n} tag has no suffix.`);if("!"===n&&"1.0"===(e.version||e.options.version)){if("^"===r[0])return e.warnings.push(new PlainValue.YAMLWarning(t,"YAML 1.0 ^ tag expansion is not supported")),r;if(/[:/]/.test(r)){const e=r.match(/^([a-z0-9-]+)\/(.*)/i);return e?`tag:${e[1]}.yaml.org,2002:${e[2]}`:`tag:${r}`}}return o.prefix+decodeURIComponent(r)}function resolveTagName(e,t){const{tag:n,type:r}=t;let o=!1;if(n){const{handle:r,suffix:s,verbatim:a}=n;if(a){if("!"!==a&&"!!"!==a)return a;const n=`Verbatim tags aren't resolved, so ${a} is invalid.`;e.errors.push(new PlainValue.YAMLSemanticError(t,n))}else if("!"!==r||s)try{return resolveTagHandle(e,t)}catch(t){e.errors.push(t)}else o=!0}switch(r){case PlainValue.Type.BLOCK_FOLDED:case PlainValue.Type.BLOCK_LITERAL:case PlainValue.Type.QUOTE_DOUBLE:case PlainValue.Type.QUOTE_SINGLE:return PlainValue.defaultTags.STR;case PlainValue.Type.FLOW_MAP:case PlainValue.Type.MAP:return PlainValue.defaultTags.MAP;case PlainValue.Type.FLOW_SEQ:case PlainValue.Type.SEQ:return PlainValue.defaultTags.SEQ;case PlainValue.Type.PLAIN:return o?PlainValue.defaultTags.STR:null;default:return null}}function resolveByTagName(e,t,n){const{tags:r}=e.schema,o=[];for(const s of r)if(s.tag===n){if(!s.test){const n=s.resolve(e,t);return n instanceof Collection?n:new Scalar(n)}o.push(s)}const s=resolveString(e,t);return"string"==typeof s&&o.length>0?resolveScalar(s,o,r.scalarFallback):null}function getFallbackTagName({type:e}){switch(e){case PlainValue.Type.FLOW_MAP:case PlainValue.Type.MAP:return PlainValue.defaultTags.MAP;case PlainValue.Type.FLOW_SEQ:case PlainValue.Type.SEQ:return PlainValue.defaultTags.SEQ;default:return PlainValue.defaultTags.STR}}function resolveTag(e,t,n){try{const r=resolveByTagName(e,t,n);if(r)return n&&t.tag&&(r.tag=n),r}catch(n){return n.source||(n.source=t),e.errors.push(n),null}try{const r=getFallbackTagName(t);if(!r)throw new Error(`The tag ${n} is unavailable`);const o=`The tag ${n} is unavailable, falling back to ${r}`;e.warnings.push(new PlainValue.YAMLWarning(t,o));const s=resolveByTagName(e,t,r);return s.tag=n,s}catch(n){const r=new PlainValue.YAMLReferenceError(t,n.message);return r.stack=n.stack,e.errors.push(r),null}}const isCollectionItem=e=>{if(!e)return!1;const{type:t}=e;return t===PlainValue.Type.MAP_KEY||t===PlainValue.Type.MAP_VALUE||t===PlainValue.Type.SEQ_ITEM};function resolveNodeProps(e,t){const n={before:[],after:[]};let r=!1,o=!1;const s=isCollectionItem(t.context.parent)?t.context.parent.props.concat(t.props):t.props;for(const{start:a,end:i}of s)switch(t.context.src[a]){case PlainValue.Char.COMMENT:{if(!t.commentHasRequiredWhitespace(a)){const n="Comments must be separated from other tokens by white space characters";e.push(new PlainValue.YAMLSemanticError(t,n))}const{header:r,valueRange:o}=t;(o&&(a>o.start||r&&a>r.start)?n.after:n.before).push(t.context.src.slice(a+1,i));break}case PlainValue.Char.ANCHOR:if(r){const n="A node can have at most one anchor";e.push(new PlainValue.YAMLSemanticError(t,n))}r=!0;break;case PlainValue.Char.TAG:if(o){const n="A node can have at most one tag";e.push(new PlainValue.YAMLSemanticError(t,n))}o=!0}return{comments:n,hasAnchor:r,hasTag:o}}function resolveNodeValue(e,t){const{anchors:n,errors:r,schema:o}=e;if(t.type===PlainValue.Type.ALIAS){const e=t.rawValue,o=n.getNode(e);if(!o){const n=`Aliased anchor not found: ${e}`;return r.push(new PlainValue.YAMLReferenceError(t,n)),null}const s=new Alias(o);return n._cstAliases.push(s),s}const s=resolveTagName(e,t);if(s)return resolveTag(e,t,s);if(t.type!==PlainValue.Type.PLAIN){const e=`Failed to resolve ${t.type} node here`;return r.push(new PlainValue.YAMLSyntaxError(t,e)),null}try{return resolveScalar(resolveString(e,t),o.tags,o.tags.scalarFallback)}catch(e){return e.source||(e.source=t),r.push(e),null}}function resolveNode(e,t){if(!t)return null;t.error&&e.errors.push(t.error);const{comments:n,hasAnchor:r,hasTag:o}=resolveNodeProps(e.errors,t);if(r){const{anchors:n}=e,r=t.anchor,o=n.getNode(r);o&&(n.map[n.newName(r)]=o),n.map[r]=t}if(t.type===PlainValue.Type.ALIAS&&(r||o)){const n="An alias node must not specify any properties";e.errors.push(new PlainValue.YAMLSemanticError(t,n))}const s=resolveNodeValue(e,t);if(s){s.range=[t.range.start,t.range.end],e.options.keepCstNodes&&(s.cstNode=t),e.options.keepNodeTypes&&(s.type=t.type);const r=n.before.join("\n");r&&(s.commentBefore=s.commentBefore?`${s.commentBefore}\n${r}`:r);const o=n.after.join("\n");o&&(s.comment=s.comment?`${s.comment}\n${o}`:o)}return t.resolved=s}function resolveMap(e,t){if(t.type!==PlainValue.Type.MAP&&t.type!==PlainValue.Type.FLOW_MAP){const n=`A ${t.type} node cannot be resolved as a mapping`;return e.errors.push(new PlainValue.YAMLSyntaxError(t,n)),null}const{comments:n,items:r}=t.type===PlainValue.Type.FLOW_MAP?resolveFlowMapItems(e,t):resolveBlockMapItems(e,t),o=new YAMLMap;o.items=r,resolveComments(o,n);let s=!1;for(let n=0;n<r.length;++n){const{key:o}=r[n];if(o instanceof Collection&&(s=!0),e.schema.merge&&o&&"<<"===o.value){r[n]=new Merge(r[n]);const o=r[n].value.items;let s=null;o.some((e=>{if(e instanceof Alias){const{type:t}=e.source;return t!==PlainValue.Type.MAP&&t!==PlainValue.Type.FLOW_MAP&&(s="Merge nodes aliases can only point to maps")}return s="Merge nodes can only have Alias nodes as values"})),s&&e.errors.push(new PlainValue.YAMLSemanticError(t,s))}else for(let s=n+1;s<r.length;++s){const{key:n}=r[s];if(o===n||o&&n&&Object.prototype.hasOwnProperty.call(o,"value")&&o.value===n.value){const n=`Map keys must be unique; "${o}" is repeated`;e.errors.push(new PlainValue.YAMLSemanticError(t,n));break}}}if(s&&!e.options.mapAsMap){const n="Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";e.warnings.push(new PlainValue.YAMLWarning(t,n))}return t.resolved=o,o}const valueHasPairComment=({context:{lineStart:e,node:t,src:n},props:r})=>{if(0===r.length)return!1;const{start:o}=r[0];if(t&&o>t.valueRange.start)return!1;if(n[o]!==PlainValue.Char.COMMENT)return!1;for(let t=e;t<o;++t)if("\n"===n[t])return!1;return!0};function resolvePairComment(e,t){if(!valueHasPairComment(e))return;const n=e.getPropValue(0,PlainValue.Char.COMMENT,!0);let r=!1;const o=t.value.commentBefore;if(o&&o.startsWith(n))t.value.commentBefore=o.substr(n.length+1),r=!0;else{const o=t.value.comment;!e.node&&o&&o.startsWith(n)&&(t.value.comment=o.substr(n.length+1),r=!0)}r&&(t.comment=n)}function resolveBlockMapItems(e,t){const n=[],r=[];let o,s=null;for(let a=0;a<t.items.length;++a){const i=t.items[a];switch(i.type){case PlainValue.Type.BLANK_LINE:n.push({afterKey:!!o,before:r.length});break;case PlainValue.Type.COMMENT:n.push({afterKey:!!o,before:r.length,comment:i.comment});break;case PlainValue.Type.MAP_KEY:void 0!==o&&r.push(new Pair(o)),i.error&&e.errors.push(i.error),o=resolveNode(e,i.node),s=null;break;case PlainValue.Type.MAP_VALUE:{if(void 0===o&&(o=null),i.error&&e.errors.push(i.error),!i.context.atLineStart&&i.node&&i.node.type===PlainValue.Type.MAP&&!i.node.context.atLineStart){const t="Nested mappings are not allowed in compact mappings";e.errors.push(new PlainValue.YAMLSemanticError(i.node,t))}let n=i.node;if(!n&&i.props.length>0){n=new PlainValue.PlainValue(PlainValue.Type.PLAIN,[]),n.context={parent:i,src:i.context.src};const e=i.range.start+1;if(n.range={start:e,end:e},n.valueRange={start:e,end:e},"number"==typeof i.range.origStart){const e=i.range.origStart+1;n.range.origStart=n.range.origEnd=e,n.valueRange.origStart=n.valueRange.origEnd=e}}const a=new Pair(o,resolveNode(e,n));resolvePairComment(i,a),r.push(a),o&&"number"==typeof s&&i.range.start>s+1024&&e.errors.push(getLongKeyError(t,o)),o=void 0,s=null}break;default:void 0!==o&&r.push(new Pair(o)),o=resolveNode(e,i),s=i.range.start,i.error&&e.errors.push(i.error);e:for(let n=a+1;;++n){const r=t.items[n];switch(r&&r.type){case PlainValue.Type.BLANK_LINE:case PlainValue.Type.COMMENT:continue e;case PlainValue.Type.MAP_VALUE:break e;default:{const t="Implicit map keys need to be followed by map values";e.errors.push(new PlainValue.YAMLSemanticError(i,t));break e}}}if(i.valueRangeContainsNewline){const t="Implicit map keys need to be on a single line";e.errors.push(new PlainValue.YAMLSemanticError(i,t))}}}return void 0!==o&&r.push(new Pair(o)),{comments:n,items:r}}function resolveFlowMapItems(e,t){const n=[],r=[];let o,s=!1,a="{";for(let i=0;i<t.items.length;++i){const l=t.items[i];if("string"==typeof l.char){const{char:n,offset:c}=l;if("?"===n&&void 0===o&&!s){s=!0,a=":";continue}if(":"===n){if(void 0===o&&(o=null),":"===a){a=",";continue}}else if(s&&(void 0===o&&","!==n&&(o=null),s=!1),void 0!==o&&(r.push(new Pair(o)),o=void 0,","===n)){a=":";continue}if("}"===n){if(i===t.items.length-1)continue}else if(n===a){a=":";continue}const u=`Flow map contains an unexpected ${n}`,f=new PlainValue.YAMLSyntaxError(t,u);f.offset=c,e.errors.push(f)}else l.type===PlainValue.Type.BLANK_LINE?n.push({afterKey:!!o,before:r.length}):l.type===PlainValue.Type.COMMENT?(checkFlowCommentSpace(e.errors,l),n.push({afterKey:!!o,before:r.length,comment:l.comment})):void 0===o?(","===a&&e.errors.push(new PlainValue.YAMLSemanticError(l,"Separator , missing in flow map")),o=resolveNode(e,l)):(","!==a&&e.errors.push(new PlainValue.YAMLSemanticError(l,"Indicator : missing in flow map entry")),r.push(new Pair(o,resolveNode(e,l))),o=void 0,s=!1)}return checkFlowCollectionEnd(e.errors,t),void 0!==o&&r.push(new Pair(o)),{comments:n,items:r}}function resolveSeq(e,t){if(t.type!==PlainValue.Type.SEQ&&t.type!==PlainValue.Type.FLOW_SEQ){const n=`A ${t.type} node cannot be resolved as a sequence`;return e.errors.push(new PlainValue.YAMLSyntaxError(t,n)),null}const{comments:n,items:r}=t.type===PlainValue.Type.FLOW_SEQ?resolveFlowSeqItems(e,t):resolveBlockSeqItems(e,t),o=new YAMLSeq;if(o.items=r,resolveComments(o,n),!e.options.mapAsMap&&r.some((e=>e instanceof Pair&&e.key instanceof Collection))){const n="Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";e.warnings.push(new PlainValue.YAMLWarning(t,n))}return t.resolved=o,o}function resolveBlockSeqItems(e,t){const n=[],r=[];for(let o=0;o<t.items.length;++o){const s=t.items[o];switch(s.type){case PlainValue.Type.BLANK_LINE:n.push({before:r.length});break;case PlainValue.Type.COMMENT:n.push({comment:s.comment,before:r.length});break;case PlainValue.Type.SEQ_ITEM:if(s.error&&e.errors.push(s.error),r.push(resolveNode(e,s.node)),s.hasProps){const t="Sequence items cannot have tags or anchors before the - indicator";e.errors.push(new PlainValue.YAMLSemanticError(s,t))}break;default:s.error&&e.errors.push(s.error),e.errors.push(new PlainValue.YAMLSyntaxError(s,`Unexpected ${s.type} node in sequence`))}}return{comments:n,items:r}}function resolveFlowSeqItems(e,t){const n=[],r=[];let o,s=!1,a=null,i="[",l=null;for(let c=0;c<t.items.length;++c){const u=t.items[c];if("string"==typeof u.char){const{char:n,offset:f}=u;if(":"===n||!s&&void 0===o||(s&&void 0===o&&(o=i?r.pop():null),r.push(new Pair(o)),s=!1,o=void 0,a=null),n===i)i=null;else if(i||"?"!==n){if("["!==i&&":"===n&&void 0===o){if(","===i){if(o=r.pop(),o instanceof Pair){const n="Chaining flow sequence pairs is invalid",r=new PlainValue.YAMLSemanticError(t,n);r.offset=f,e.errors.push(r)}if(!s&&"number"==typeof a){const n=u.range?u.range.start:u.offset;n>a+1024&&e.errors.push(getLongKeyError(t,o));const{src:r}=l.context;for(let t=a;t<n;++t)if("\n"===r[t]){const t="Implicit keys of flow sequence pairs need to be on a single line";e.errors.push(new PlainValue.YAMLSemanticError(l,t));break}}}else o=null;a=null,s=!1,i=null}else if("["===i||"]"!==n||c<t.items.length-1){const r=`Flow sequence contains an unexpected ${n}`,o=new PlainValue.YAMLSyntaxError(t,r);o.offset=f,e.errors.push(o)}}else s=!0}else if(u.type===PlainValue.Type.BLANK_LINE)n.push({before:r.length});else if(u.type===PlainValue.Type.COMMENT)checkFlowCommentSpace(e.errors,u),n.push({comment:u.comment,before:r.length});else{if(i){const t=`Expected a ${i} in flow sequence`;e.errors.push(new PlainValue.YAMLSemanticError(u,t))}const t=resolveNode(e,u);void 0===o?(r.push(t),l=u):(r.push(new Pair(o,t)),o=void 0),a=u.range.start,i=","}}return checkFlowCollectionEnd(e.errors,t),void 0!==o&&r.push(new Pair(o)),{comments:n,items:r}}exports.Alias=Alias,exports.Collection=Collection,exports.Merge=Merge,exports.Node=Node,exports.Pair=Pair,exports.Scalar=Scalar,exports.YAMLMap=YAMLMap,exports.YAMLSeq=YAMLSeq,exports.addComment=addComment,exports.binaryOptions=binaryOptions,exports.boolOptions=boolOptions,exports.findPair=findPair,exports.intOptions=intOptions,exports.isEmptyPath=isEmptyPath,exports.nullOptions=nullOptions,exports.resolveMap=resolveMap,exports.resolveNode=resolveNode,exports.resolveSeq=resolveSeq,exports.resolveString=resolveString,exports.strOptions=strOptions,exports.stringifyNumber=stringifyNumber,exports.stringifyString=stringifyString,exports.toJSON=toJSON;
