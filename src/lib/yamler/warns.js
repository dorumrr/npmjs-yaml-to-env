var PlainValue=require("./pval.js"),resolveSeq=require("./seqres.js");const binary={identify:e=>e instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve:(e,t)=>{const r=resolveSeq.resolveString(e,t);if("function"==typeof Buffer)return Buffer.from(r,"base64");if("function"==typeof atob){const e=atob(r.replace(/[\n\r]/g,"")),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t}{const r="This environment does not support reading binary tags; either Buffer or atob is required";return e.errors.push(new PlainValue.YAMLReferenceError(t,r)),null}},options:resolveSeq.binaryOptions,stringify:({comment:e,type:t,value:r},n,a,o)=>{let s;if("function"==typeof Buffer)s=r instanceof Buffer?r.toString("base64"):Buffer.from(r.buffer).toString("base64");else{if("function"!=typeof btoa)throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");{let e="";for(let t=0;t<r.length;++t)e+=String.fromCharCode(r[t]);s=btoa(e)}}if(t||(t=resolveSeq.binaryOptions.defaultType),t===PlainValue.Type.QUOTE_DOUBLE)r=s;else{const{lineWidth:e}=resolveSeq.binaryOptions,n=Math.ceil(s.length/e),a=new Array(n);for(let t=0,r=0;t<n;++t,r+=e)a[t]=s.substr(r,e);r=a.join(t===PlainValue.Type.BLOCK_LITERAL?"\n":" ")}return resolveSeq.stringifyString({comment:e,type:t,value:r},n,a,o)}};function parsePairs(e,t){const r=resolveSeq.resolveSeq(e,t);for(let e=0;e<r.items.length;++e){let n=r.items[e];if(!(n instanceof resolveSeq.Pair)){if(n instanceof resolveSeq.YAMLMap){if(n.items.length>1){const e="Each pair must have its own sequence indicator";throw new PlainValue.YAMLSemanticError(t,e)}const e=n.items[0]||new resolveSeq.Pair;n.commentBefore&&(e.commentBefore=e.commentBefore?`${n.commentBefore}\n${e.commentBefore}`:n.commentBefore),n.comment&&(e.comment=e.comment?`${n.comment}\n${e.comment}`:n.comment),n=e}r.items[e]=n instanceof resolveSeq.Pair?n:new resolveSeq.Pair(n)}}return r}function createPairs(e,t,r){const n=new resolveSeq.YAMLSeq(e);n.tag="tag:yaml.org,2002:pairs";for(const a of t){let t,o;if(Array.isArray(a)){if(2!==a.length)throw new TypeError(`Expected [key, value] tuple: ${a}`);t=a[0],o=a[1]}else if(a&&a instanceof Object){const e=Object.keys(a);if(1!==e.length)throw new TypeError(`Expected { key: value } tuple: ${a}`);t=e[0],o=a[t]}else t=a;const s=e.createPair(t,o,r);n.items.push(s)}return n}const pairs={default:!1,tag:"tag:yaml.org,2002:pairs",resolve:parsePairs,createNode:createPairs};class YAMLOMap extends resolveSeq.YAMLSeq{constructor(){super(),PlainValue._defineProperty(this,"add",resolveSeq.YAMLMap.prototype.add.bind(this)),PlainValue._defineProperty(this,"delete",resolveSeq.YAMLMap.prototype.delete.bind(this)),PlainValue._defineProperty(this,"get",resolveSeq.YAMLMap.prototype.get.bind(this)),PlainValue._defineProperty(this,"has",resolveSeq.YAMLMap.prototype.has.bind(this)),PlainValue._defineProperty(this,"set",resolveSeq.YAMLMap.prototype.set.bind(this)),this.tag=YAMLOMap.tag}toJSON(e,t){const r=new Map;t&&t.onCreate&&t.onCreate(r);for(const e of this.items){let n,a;if(e instanceof resolveSeq.Pair?(n=resolveSeq.toJSON(e.key,"",t),a=resolveSeq.toJSON(e.value,n,t)):n=resolveSeq.toJSON(e,"",t),r.has(n))throw new Error("Ordered maps must not include duplicate keys");r.set(n,a)}return r}}function parseOMap(e,t){const r=parsePairs(e,t),n=[];for(const{key:e}of r.items)if(e instanceof resolveSeq.Scalar){if(n.includes(e.value)){const e="Ordered maps must not include duplicate keys";throw new PlainValue.YAMLSemanticError(t,e)}n.push(e.value)}return Object.assign(new YAMLOMap,r)}function createOMap(e,t,r){const n=createPairs(e,t,r),a=new YAMLOMap;return a.items=n.items,a}PlainValue._defineProperty(YAMLOMap,"tag","tag:yaml.org,2002:omap");const omap={identify:e=>e instanceof Map,nodeClass:YAMLOMap,default:!1,tag:"tag:yaml.org,2002:omap",resolve:parseOMap,createNode:createOMap};class YAMLSet extends resolveSeq.YAMLMap{constructor(){super(),this.tag=YAMLSet.tag}add(e){const t=e instanceof resolveSeq.Pair?e:new resolveSeq.Pair(e);resolveSeq.findPair(this.items,t.key)||this.items.push(t)}get(e,t){const r=resolveSeq.findPair(this.items,e);return!t&&r instanceof resolveSeq.Pair?r.key instanceof resolveSeq.Scalar?r.key.value:r.key:r}set(e,t){if("boolean"!=typeof t)throw new Error("Expected boolean value for set(key, value) in a YAML set, not "+typeof t);const r=resolveSeq.findPair(this.items,e);r&&!t?this.items.splice(this.items.indexOf(r),1):!r&&t&&this.items.push(new resolveSeq.Pair(e))}toJSON(e,t){return super.toJSON(e,t,Set)}toString(e,t,r){if(!e)return JSON.stringify(this);if(this.hasAllNullValues())return super.toString(e,t,r);throw new Error("Set items must all have null values")}}function parseSet(e,t){const r=resolveSeq.resolveMap(e,t);if(!r.hasAllNullValues())throw new PlainValue.YAMLSemanticError(t,"Set items must all have null values");return Object.assign(new YAMLSet,r)}function createSet(e,t,r){const n=new YAMLSet;for(const a of t)n.items.push(e.createPair(a,null,r));return n}PlainValue._defineProperty(YAMLSet,"tag","tag:yaml.org,2002:set");const set={identify:e=>e instanceof Set,nodeClass:YAMLSet,default:!1,tag:"tag:yaml.org,2002:set",resolve:parseSet,createNode:createSet},parseSexagesimal=(e,t)=>{const r=t.split(":").reduce(((e,t)=>60*e+Number(t)),0);return"-"===e?-r:r},stringifySexagesimal=({value:e})=>{if(isNaN(e)||!isFinite(e))return resolveSeq.stringifyNumber(e);let t="";e<0&&(t="-",e=Math.abs(e));const r=[e%60];return e<60?r.unshift(0):(e=Math.round((e-r[0])/60),r.unshift(e%60),e>=60&&(e=Math.round((e-r[0])/60),r.unshift(e))),t+r.map((e=>e<10?"0"+String(e):String(e))).join(":").replace(/000000\d*$/,"")},intTime={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,resolve:(e,t,r)=>parseSexagesimal(t,r.replace(/_/g,"")),stringify:stringifySexagesimal},floatTime={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,resolve:(e,t,r)=>parseSexagesimal(t,r.replace(/_/g,"")),stringify:stringifySexagesimal},timestamp={identify:e=>e instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),resolve:(e,t,r,n,a,o,s,i,l)=>{i&&(i=(i+"00").substr(1,3));let f=Date.UTC(t,r-1,n,a||0,o||0,s||0,i||0);if(l&&"Z"!==l){let e=parseSexagesimal(l[0],l.slice(1));Math.abs(e)<30&&(e*=60),f-=6e4*e}return new Date(f)},stringify:({value:e})=>e.toISOString().replace(/((T00:00)?:00)?\.000Z$/,"")};function shouldWarn(e){const t="undefined"!=typeof process&&process.env||{};return e?"undefined"!=typeof YAML_SILENCE_DEPRECATION_WARNINGS?!YAML_SILENCE_DEPRECATION_WARNINGS:!t.YAML_SILENCE_DEPRECATION_WARNINGS:"undefined"!=typeof YAML_SILENCE_WARNINGS?!YAML_SILENCE_WARNINGS:!t.YAML_SILENCE_WARNINGS}function warn(e,t){if(shouldWarn(!1)){const r="undefined"!=typeof process&&process.emitWarning;r?r(e,t):console.warn(t?`${t}: ${e}`:e)}}function warnFileDeprecation(e){if(shouldWarn(!0)){warn(`The endpoint 'yaml/${e.replace(/.*yaml[/\\]/i,"").replace(/\.js$/,"").replace(/\\/g,"/")}' will be removed in a future release.`,"DeprecationWarning")}}const warned={};function warnOptionDeprecation(e,t){if(!warned[e]&&shouldWarn(!0)){warned[e]=!0;let r=`The option '${e}' will be removed in a future release`;r+=t?`, use '${t}' instead.`:".",warn(r,"DeprecationWarning")}}exports.binary=binary,exports.floatTime=floatTime,exports.intTime=intTime,exports.omap=omap,exports.pairs=pairs,exports.set=set,exports.timestamp=timestamp,exports.warn=warn,exports.warnFileDeprecation=warnFileDeprecation,exports.warnOptionDeprecation=warnOptionDeprecation;
