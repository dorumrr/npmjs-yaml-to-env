var PlainValue=require("./pval.js");class BlankLine extends PlainValue.Node{constructor(){super(PlainValue.Type.BLANK_LINE)}get includesTrailingLines(){return!0}parse(e,n){return this.context=e,this.range=new PlainValue.Range(n,n+1),n+1}}class CollectionItem extends PlainValue.Node{constructor(e,n){super(e,n),this.node=null}get includesTrailingLines(){return!!this.node&&this.node.includesTrailingLines}parse(e,n){this.context=e;const{parseNode:t,src:a}=e;let{atLineStart:s,lineStart:i}=e;s||this.type!==PlainValue.Type.SEQ_ITEM||(this.error=new PlainValue.YAMLSemanticError(this,"Sequence items must not have preceding content on the same line"));const r=s?n-i:e.indent;let l=PlainValue.Node.endOfWhiteSpace(a,n+1),o=a[l];const c="#"===o,u=[];let h=null;for(;"\n"===o||"#"===o;){if("#"===o){const e=PlainValue.Node.endOfLine(a,l+1);u.push(new PlainValue.Range(l,e)),l=e}else{s=!0,i=l+1;"\n"===a[PlainValue.Node.endOfWhiteSpace(a,i)]&&0===u.length&&(h=new BlankLine,i=h.parse({src:a},i)),l=PlainValue.Node.endOfIndent(a,i)}o=a[l]}if(PlainValue.Node.nextNodeIsIndented(o,l-(i+r),this.type!==PlainValue.Type.SEQ_ITEM)?this.node=t({atLineStart:s,inCollection:!1,indent:r,lineStart:i,parent:this},l):o&&i>n+1&&(l=i-1),this.node){if(h){const n=e.parent.items||e.parent.contents;n&&n.push(h)}u.length&&Array.prototype.push.apply(this.props,u),l=this.node.range.end}else if(c){const e=u[0];this.props.push(e),l=e.end}else l=PlainValue.Node.endOfLine(a,n+1);const d=this.node?this.node.valueRange.end:l;return this.valueRange=new PlainValue.Range(n,d),l}setOrigRanges(e,n){return n=super.setOrigRanges(e,n),this.node?this.node.setOrigRanges(e,n):n}toString(){const{context:{src:e},node:n,range:t,value:a}=this;if(null!=a)return a;const s=n?e.slice(t.start,n.range.start)+String(n):e.slice(t.start,t.end);return PlainValue.Node.addStringTerminator(e,t.end,s)}}class Comment extends PlainValue.Node{constructor(){super(PlainValue.Type.COMMENT)}parse(e,n){this.context=e;const t=this.parseComment(n);return this.range=new PlainValue.Range(n,t),t}}function grabCollectionEndComments(e){let n=e;for(;n instanceof CollectionItem;)n=n.node;if(!(n instanceof Collection))return null;const t=n.items.length;let a=-1;for(let e=t-1;e>=0;--e){const t=n.items[e];if(t.type===PlainValue.Type.COMMENT){const{indent:n,lineStart:s}=t.context;if(n>0&&t.range.start>=s+n)break;a=e}else{if(t.type!==PlainValue.Type.BLANK_LINE)break;a=e}}if(-1===a)return null;const s=n.items.splice(a,t-a),i=s[0].range.start;for(;n.range.end=i,n.valueRange&&n.valueRange.end>i&&(n.valueRange.end=i),n!==e;)n=n.context.parent;return s}class Collection extends PlainValue.Node{static nextContentHasIndent(e,n,t){const a=PlainValue.Node.endOfLine(e,n)+1,s=e[n=PlainValue.Node.endOfWhiteSpace(e,a)];return!!s&&(n>=a+t||("#"===s||"\n"===s)&&Collection.nextContentHasIndent(e,n,t))}constructor(e){super(e.type===PlainValue.Type.SEQ_ITEM?PlainValue.Type.SEQ:PlainValue.Type.MAP);for(let n=e.props.length-1;n>=0;--n)if(e.props[n].start<e.context.lineStart){this.props=e.props.slice(0,n+1),e.props=e.props.slice(n+1);const t=e.props[0]||e.valueRange;e.range.start=t.start;break}this.items=[e];const n=grabCollectionEndComments(e);n&&Array.prototype.push.apply(this.items,n)}get includesTrailingLines(){return this.items.length>0}parse(e,n){this.context=e;const{parseNode:t,src:a}=e;let s=PlainValue.Node.startOfLine(a,n);const i=this.items[0];i.context.parent=this,this.valueRange=PlainValue.Range.copy(i.valueRange);const r=i.range.start-i.context.lineStart;let l=n;l=PlainValue.Node.normalizeOffset(a,l);let o=a[l],c=PlainValue.Node.endOfWhiteSpace(a,s)===l,u=!1;for(;o;){for(;"\n"===o||"#"===o;){if(c&&"\n"===o&&!u){const e=new BlankLine;if(l=e.parse({src:a},l),this.valueRange.end=l,l>=a.length){o=null;break}this.items.push(e),l-=1}else if("#"===o){if(l<s+r&&!Collection.nextContentHasIndent(a,l,r))return l;const e=new Comment;if(l=e.parse({indent:r,lineStart:s,src:a},l),this.items.push(e),this.valueRange.end=l,l>=a.length){o=null;break}}if(s=l+1,l=PlainValue.Node.endOfIndent(a,s),PlainValue.Node.atBlank(a,l)){const e=PlainValue.Node.endOfWhiteSpace(a,l),n=a[e];n&&"\n"!==n&&"#"!==n||(l=e)}o=a[l],c=!0}if(!o)break;if(l!==s+r&&(c||":"!==o)){if(l<s+r){s>n&&(l=s);break}if(!this.error){const e="All collection items must start at the same column";this.error=new PlainValue.YAMLSyntaxError(this,e)}}if(i.type===PlainValue.Type.SEQ_ITEM){if("-"!==o){s>n&&(l=s);break}}else if("-"===o&&!this.error){const e=a[l+1];if(!e||"\n"===e||"\t"===e||" "===e){const e="A collection cannot be both a mapping and a sequence";this.error=new PlainValue.YAMLSyntaxError(this,e)}}const e=t({atLineStart:c,inCollection:!0,indent:r,lineStart:s,parent:this},l);if(!e)return l;if(this.items.push(e),this.valueRange.end=e.valueRange.end,l=PlainValue.Node.normalizeOffset(a,e.range.end),o=a[l],c=!1,u=e.includesTrailingLines,o){let e=l-1,n=a[e];for(;" "===n||"\t"===n;)n=a[--e];"\n"===n&&(s=e+1,c=!0)}const h=grabCollectionEndComments(e);h&&Array.prototype.push.apply(this.items,h)}return l}setOrigRanges(e,n){return n=super.setOrigRanges(e,n),this.items.forEach((t=>{n=t.setOrigRanges(e,n)})),n}toString(){const{context:{src:e},items:n,range:t,value:a}=this;if(null!=a)return a;let s=e.slice(t.start,n[0].range.start)+String(n[0]);for(let e=1;e<n.length;++e){const t=n[e],{atLineStart:a,indent:i}=t.context;if(a)for(let e=0;e<i;++e)s+=" ";s+=String(t)}return PlainValue.Node.addStringTerminator(e,t.end,s)}}class Directive extends PlainValue.Node{constructor(){super(PlainValue.Type.DIRECTIVE),this.name=null}get parameters(){const e=this.rawValue;return e?e.trim().split(/[ \t]+/):[]}parseName(e){const{src:n}=this.context;let t=e,a=n[t];for(;a&&"\n"!==a&&"\t"!==a&&" "!==a;)a=n[t+=1];return this.name=n.slice(e,t),t}parseParameters(e){const{src:n}=this.context;let t=e,a=n[t];for(;a&&"\n"!==a&&"#"!==a;)a=n[t+=1];return this.valueRange=new PlainValue.Range(e,t),t}parse(e,n){this.context=e;let t=this.parseName(n+1);return t=this.parseParameters(t),t=this.parseComment(t),this.range=new PlainValue.Range(n,t),t}}class Document extends PlainValue.Node{static startCommentOrEndBlankLine(e,n){const t=PlainValue.Node.endOfWhiteSpace(e,n),a=e[t];return"#"===a||"\n"===a?t:n}constructor(){super(PlainValue.Type.DOCUMENT),this.directives=null,this.contents=null,this.directivesEndMarker=null,this.documentEndMarker=null}parseDirectives(e){const{src:n}=this.context;this.directives=[];let t=!0,a=!1,s=e;for(;!PlainValue.Node.atDocumentBoundary(n,s,PlainValue.Char.DIRECTIVES_END);)switch(s=Document.startCommentOrEndBlankLine(n,s),n[s]){case"\n":if(t){const e=new BlankLine;s=e.parse({src:n},s),s<n.length&&this.directives.push(e)}else s+=1,t=!0;break;case"#":{const e=new Comment;s=e.parse({src:n},s),this.directives.push(e),t=!1}break;case"%":{const e=new Directive;s=e.parse({parent:this,src:n},s),this.directives.push(e),a=!0,t=!1}break;default:return a?this.error=new PlainValue.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),s}return n[s]?(this.directivesEndMarker=new PlainValue.Range(s,s+3),s+3):(a?this.error=new PlainValue.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),s)}parseContents(e){const{parseNode:n,src:t}=this.context;this.contents||(this.contents=[]);let a=e;for(;"-"===t[a-1];)a-=1;let s=PlainValue.Node.endOfWhiteSpace(t,e),i=a===e;for(this.valueRange=new PlainValue.Range(s);!PlainValue.Node.atDocumentBoundary(t,s,PlainValue.Char.DOCUMENT_END);){switch(t[s]){case"\n":if(i){const e=new BlankLine;s=e.parse({src:t},s),s<t.length&&this.contents.push(e)}else s+=1,i=!0;a=s;break;case"#":{const e=new Comment;s=e.parse({src:t},s),this.contents.push(e),i=!1}break;default:{const e=PlainValue.Node.endOfIndent(t,s),r=n({atLineStart:i,indent:-1,inFlow:!1,inCollection:!1,lineStart:a,parent:this},e);if(!r)return this.valueRange.end=e;this.contents.push(r),s=r.range.end,i=!1;const l=grabCollectionEndComments(r);l&&Array.prototype.push.apply(this.contents,l)}}s=Document.startCommentOrEndBlankLine(t,s)}if(this.valueRange.end=s,t[s]&&(this.documentEndMarker=new PlainValue.Range(s,s+3),s+=3,t[s])){if(s=PlainValue.Node.endOfWhiteSpace(t,s),"#"===t[s]){const e=new Comment;s=e.parse({src:t},s),this.contents.push(e)}switch(t[s]){case"\n":s+=1;break;case void 0:break;default:this.error=new PlainValue.YAMLSyntaxError(this,"Document end marker line cannot have a non-comment suffix")}}return s}parse(e,n){e.root=this,this.context=e;const{src:t}=e;let a=65279===t.charCodeAt(n)?n+1:n;return a=this.parseDirectives(a),a=this.parseContents(a),a}setOrigRanges(e,n){return n=super.setOrigRanges(e,n),this.directives.forEach((t=>{n=t.setOrigRanges(e,n)})),this.directivesEndMarker&&(n=this.directivesEndMarker.setOrigRange(e,n)),this.contents.forEach((t=>{n=t.setOrigRanges(e,n)})),this.documentEndMarker&&(n=this.documentEndMarker.setOrigRange(e,n)),n}toString(){const{contents:e,directives:n,value:t}=this;if(null!=t)return t;let a=n.join("");return e.length>0&&((n.length>0||e[0].type===PlainValue.Type.COMMENT)&&(a+="---\n"),a+=e.join("")),"\n"!==a[a.length-1]&&(a+="\n"),a}}class Alias extends PlainValue.Node{parse(e,n){this.context=e;const{src:t}=e;let a=PlainValue.Node.endOfIdentifier(t,n+1);return this.valueRange=new PlainValue.Range(n+1,a),a=PlainValue.Node.endOfWhiteSpace(t,a),a=this.parseComment(a),a}}const Chomp={CLIP:"CLIP",KEEP:"KEEP",STRIP:"STRIP"};class BlockValue extends PlainValue.Node{constructor(e,n){super(e,n),this.blockIndent=null,this.chomping=Chomp.CLIP,this.header=null}get includesTrailingLines(){return this.chomping===Chomp.KEEP}get strValue(){if(!this.valueRange||!this.context)return null;let{start:e,end:n}=this.valueRange;const{indent:t,src:a}=this.context;if(this.valueRange.isEmpty())return"";let s=null,i=a[n-1];for(;"\n"===i||"\t"===i||" "===i;){if(n-=1,n<=e){if(this.chomping===Chomp.KEEP)break;return""}"\n"===i&&(s=n),i=a[n-1]}let r=n+1;s&&(this.chomping===Chomp.KEEP?(r=s,n=this.valueRange.end):n=s);const l=t+this.blockIndent,o=this.type===PlainValue.Type.BLOCK_FOLDED;let c=!0,u="",h="",d=!1;for(let t=e;t<n;++t){for(let e=0;e<l&&" "===a[t];++e)t+=1;const e=a[t];if("\n"===e)"\n"===h?u+="\n":h="\n";else{const s=PlainValue.Node.endOfLine(a,t),i=a.slice(t,s);t=s,o&&(" "===e||"\t"===e)&&t<r?(" "===h?h="\n":d||c||"\n"!==h||(h="\n\n"),u+=h+i,h=s<n&&a[s]||"",d=!0):(u+=h+i,h=o&&t<r?" ":"\n",d=!1),c&&""!==i&&(c=!1)}}return this.chomping===Chomp.STRIP?u:u+"\n"}parseBlockHeader(e){const{src:n}=this.context;let t=e+1,a="";for(;;){const s=n[t];switch(s){case"-":this.chomping=Chomp.STRIP;break;case"+":this.chomping=Chomp.KEEP;break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":a+=s;break;default:return this.blockIndent=Number(a)||null,this.header=new PlainValue.Range(e,t),t}t+=1}}parseBlockValue(e){const{indent:n,src:t}=this.context,a=!!this.blockIndent;let s=e,i=e,r=1;for(let e=t[s];"\n"===e&&(s+=1,!PlainValue.Node.atDocumentBoundary(t,s));e=t[s]){const e=PlainValue.Node.endOfBlockIndent(t,n,s);if(null===e)break;const l=t[e],o=e-(s+n);if(this.blockIndent){if(l&&"\n"!==l&&o<this.blockIndent){if("#"===t[e])break;if(!this.error){const e=`Block scalars must not be less indented than their ${a?"explicit indentation indicator":"first line"}`;this.error=new PlainValue.YAMLSemanticError(this,e)}}}else if("\n"!==t[e]){if(o<r){const e="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";this.error=new PlainValue.YAMLSemanticError(this,e)}this.blockIndent=o}else o>r&&(r=o);s="\n"===t[e]?e:i=PlainValue.Node.endOfLine(t,e)}return this.chomping!==Chomp.KEEP&&(s=t[i]?i+1:i),this.valueRange=new PlainValue.Range(e+1,s),s}parse(e,n){this.context=e;const{src:t}=e;let a=this.parseBlockHeader(n);return a=PlainValue.Node.endOfWhiteSpace(t,a),a=this.parseComment(a),a=this.parseBlockValue(a),a}setOrigRanges(e,n){return n=super.setOrigRanges(e,n),this.header?this.header.setOrigRange(e,n):n}}class FlowCollection extends PlainValue.Node{constructor(e,n){super(e,n),this.items=null}prevNodeIsJsonLike(e=this.items.length){const n=this.items[e-1];return!!n&&(n.jsonLike||n.type===PlainValue.Type.COMMENT&&this.prevNodeIsJsonLike(e-1))}parse(e,n){this.context=e;const{parseNode:t,src:a}=e;let{indent:s,lineStart:i}=e,r=a[n];this.items=[{char:r,offset:n}];let l=PlainValue.Node.endOfWhiteSpace(a,n+1);for(r=a[l];r&&"]"!==r&&"}"!==r;){switch(r){case"\n":i=l+1;if("\n"===a[PlainValue.Node.endOfWhiteSpace(a,i)]){const e=new BlankLine;i=e.parse({src:a},i),this.items.push(e)}if(l=PlainValue.Node.endOfIndent(a,i),l<=i+s&&(r=a[l],l<i+s||"]"!==r&&"}"!==r)){const e="Insufficient indentation in flow collection";this.error=new PlainValue.YAMLSemanticError(this,e)}break;case",":this.items.push({char:r,offset:l}),l+=1;break;case"#":{const e=new Comment;l=e.parse({src:a},l),this.items.push(e)}break;case"?":case":":{const e=a[l+1];if("\n"===e||"\t"===e||" "===e||","===e||":"===r&&this.prevNodeIsJsonLike()){this.items.push({char:r,offset:l}),l+=1;break}}default:{const e=t({atLineStart:!1,inCollection:!1,inFlow:!0,indent:-1,lineStart:i,parent:this},l);if(!e)return this.valueRange=new PlainValue.Range(n,l),l;this.items.push(e),l=PlainValue.Node.normalizeOffset(a,e.range.end)}}l=PlainValue.Node.endOfWhiteSpace(a,l),r=a[l]}return this.valueRange=new PlainValue.Range(n,l+1),r&&(this.items.push({char:r,offset:l}),l=PlainValue.Node.endOfWhiteSpace(a,l+1),l=this.parseComment(l)),l}setOrigRanges(e,n){return n=super.setOrigRanges(e,n),this.items.forEach((t=>{if(t instanceof PlainValue.Node)n=t.setOrigRanges(e,n);else if(0===e.length)t.origOffset=t.offset;else{let a=n;for(;a<e.length&&!(e[a]>t.offset);)++a;t.origOffset=t.offset+a,n=a}})),n}toString(){const{context:{src:e},items:n,range:t,value:a}=this;if(null!=a)return a;const s=n.filter((e=>e instanceof PlainValue.Node));let i="",r=t.start;return s.forEach((n=>{const t=e.slice(r,n.range.start);r=n.range.end,i+=t+String(n),"\n"===i[i.length-1]&&"\n"!==e[r-1]&&"\n"===e[r]&&(r+=1)})),i+=e.slice(r,t.end),PlainValue.Node.addStringTerminator(e,t.end,i)}}class QuoteDouble extends PlainValue.Node{static endOfQuote(e,n){let t=e[n];for(;t&&'"'!==t;)t=e[n+="\\"===t?2:1];return n+1}get strValue(){if(!this.valueRange||!this.context)return null;const e=[],{start:n,end:t}=this.valueRange,{indent:a,src:s}=this.context;'"'!==s[t-1]&&e.push(new PlainValue.YAMLSyntaxError(this,'Missing closing "quote'));let i="";for(let r=n+1;r<t-1;++r){const n=s[r];if("\n"===n){PlainValue.Node.atDocumentBoundary(s,r+1)&&e.push(new PlainValue.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));const{fold:n,offset:t,error:l}=PlainValue.Node.foldNewline(s,r,a);i+=n,r=t,l&&e.push(new PlainValue.YAMLSemanticError(this,"Multi-line double-quoted string needs to be sufficiently indented"))}else if("\\"===n)switch(r+=1,s[r]){case"0":i+="\0";break;case"a":i+="";break;case"b":i+="\b";break;case"e":i+="";break;case"f":i+="\f";break;case"n":i+="\n";break;case"r":i+="\r";break;case"t":case"\t":i+="\t";break;case"v":i+="\v";break;case"N":i+="Â…";break;case"_":i+="Â ";break;case"L":i+="\u2028";break;case"P":i+="\u2029";break;case" ":i+=" ";break;case'"':i+='"';break;case"/":i+="/";break;case"\\":i+="\\";break;case"x":i+=this.parseCharCode(r+1,2,e),r+=2;break;case"u":i+=this.parseCharCode(r+1,4,e),r+=4;break;case"U":i+=this.parseCharCode(r+1,8,e),r+=8;break;case"\n":for(;" "===s[r+1]||"\t"===s[r+1];)r+=1;break;default:e.push(new PlainValue.YAMLSyntaxError(this,`Invalid escape sequence ${s.substr(r-1,2)}`)),i+="\\"+s[r]}else if(" "===n||"\t"===n){const e=r;let t=s[r+1];for(;" "===t||"\t"===t;)r+=1,t=s[r+1];"\n"!==t&&(i+=r>e?s.slice(e,r+1):n)}else i+=n}return e.length>0?{errors:e,str:i}:i}parseCharCode(e,n,t){const{src:a}=this.context,s=a.substr(e,n),i=s.length===n&&/^[0-9a-fA-F]+$/.test(s)?parseInt(s,16):NaN;return isNaN(i)?(t.push(new PlainValue.YAMLSyntaxError(this,`Invalid escape sequence ${a.substr(e-2,n+2)}`)),a.substr(e-2,n+2)):String.fromCodePoint(i)}parse(e,n){this.context=e;const{src:t}=e;let a=QuoteDouble.endOfQuote(t,n+1);return this.valueRange=new PlainValue.Range(n,a),a=PlainValue.Node.endOfWhiteSpace(t,a),a=this.parseComment(a),a}}class QuoteSingle extends PlainValue.Node{static endOfQuote(e,n){let t=e[n];for(;t;)if("'"===t){if("'"!==e[n+1])break;t=e[n+=2]}else t=e[n+=1];return n+1}get strValue(){if(!this.valueRange||!this.context)return null;const e=[],{start:n,end:t}=this.valueRange,{indent:a,src:s}=this.context;"'"!==s[t-1]&&e.push(new PlainValue.YAMLSyntaxError(this,"Missing closing 'quote"));let i="";for(let r=n+1;r<t-1;++r){const n=s[r];if("\n"===n){PlainValue.Node.atDocumentBoundary(s,r+1)&&e.push(new PlainValue.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));const{fold:n,offset:t,error:l}=PlainValue.Node.foldNewline(s,r,a);i+=n,r=t,l&&e.push(new PlainValue.YAMLSemanticError(this,"Multi-line single-quoted string needs to be sufficiently indented"))}else if("'"===n)i+=n,r+=1,"'"!==s[r]&&e.push(new PlainValue.YAMLSyntaxError(this,"Unescaped single quote? This should not happen."));else if(" "===n||"\t"===n){const e=r;let t=s[r+1];for(;" "===t||"\t"===t;)r+=1,t=s[r+1];"\n"!==t&&(i+=r>e?s.slice(e,r+1):n)}else i+=n}return e.length>0?{errors:e,str:i}:i}parse(e,n){this.context=e;const{src:t}=e;let a=QuoteSingle.endOfQuote(t,n+1);return this.valueRange=new PlainValue.Range(n,a),a=PlainValue.Node.endOfWhiteSpace(t,a),a=this.parseComment(a),a}}function createNewNode(e,n){switch(e){case PlainValue.Type.ALIAS:return new Alias(e,n);case PlainValue.Type.BLOCK_FOLDED:case PlainValue.Type.BLOCK_LITERAL:return new BlockValue(e,n);case PlainValue.Type.FLOW_MAP:case PlainValue.Type.FLOW_SEQ:return new FlowCollection(e,n);case PlainValue.Type.MAP_KEY:case PlainValue.Type.MAP_VALUE:case PlainValue.Type.SEQ_ITEM:return new CollectionItem(e,n);case PlainValue.Type.COMMENT:case PlainValue.Type.PLAIN:return new PlainValue.PlainValue(e,n);case PlainValue.Type.QUOTE_DOUBLE:return new QuoteDouble(e,n);case PlainValue.Type.QUOTE_SINGLE:return new QuoteSingle(e,n);default:return null}}class ParseContext{static parseType(e,n,t){switch(e[n]){case"*":return PlainValue.Type.ALIAS;case">":return PlainValue.Type.BLOCK_FOLDED;case"|":return PlainValue.Type.BLOCK_LITERAL;case"{":return PlainValue.Type.FLOW_MAP;case"[":return PlainValue.Type.FLOW_SEQ;case"?":return!t&&PlainValue.Node.atBlank(e,n+1,!0)?PlainValue.Type.MAP_KEY:PlainValue.Type.PLAIN;case":":return!t&&PlainValue.Node.atBlank(e,n+1,!0)?PlainValue.Type.MAP_VALUE:PlainValue.Type.PLAIN;case"-":return!t&&PlainValue.Node.atBlank(e,n+1,!0)?PlainValue.Type.SEQ_ITEM:PlainValue.Type.PLAIN;case'"':return PlainValue.Type.QUOTE_DOUBLE;case"'":return PlainValue.Type.QUOTE_SINGLE;default:return PlainValue.Type.PLAIN}}constructor(e={},{atLineStart:n,inCollection:t,inFlow:a,indent:s,lineStart:i,parent:r}={}){PlainValue._defineProperty(this,"parseNode",((e,n)=>{if(PlainValue.Node.atDocumentBoundary(this.src,n))return null;const t=new ParseContext(this,e),{props:a,type:s,valueStart:i}=t.parseProps(n),r=createNewNode(s,a);let l=r.parse(t,i);if(r.range=new PlainValue.Range(n,l),l<=n&&(r.error=new Error("Node#parse consumed no characters"),r.error.parseEnd=l,r.error.source=r,r.range.end=n+1),t.nodeStartsCollection(r)){r.error||t.atLineStart||t.parent.type!==PlainValue.Type.DOCUMENT||(r.error=new PlainValue.YAMLSyntaxError(r,"Block collection must not have preceding content here (e.g. directives-end indicator)"));const e=new Collection(r);return l=e.parse(new ParseContext(t),l),e.range=new PlainValue.Range(n,l),e}return r})),this.atLineStart=null!=n?n:e.atLineStart||!1,this.inCollection=null!=t?t:e.inCollection||!1,this.inFlow=null!=a?a:e.inFlow||!1,this.indent=null!=s?s:e.indent,this.lineStart=null!=i?i:e.lineStart,this.parent=null!=r?r:e.parent||{},this.root=e.root,this.src=e.src}nodeStartsCollection(e){const{inCollection:n,inFlow:t,src:a}=this;if(n||t)return!1;if(e instanceof CollectionItem)return!0;let s=e.range.end;return"\n"!==a[s]&&"\n"!==a[s-1]&&(s=PlainValue.Node.endOfWhiteSpace(a,s),":"===a[s])}parseProps(e){const{inFlow:n,parent:t,src:a}=this,s=[];let i=!1,r=a[e=this.atLineStart?PlainValue.Node.endOfIndent(a,e):PlainValue.Node.endOfWhiteSpace(a,e)];for(;r===PlainValue.Char.ANCHOR||r===PlainValue.Char.COMMENT||r===PlainValue.Char.TAG||"\n"===r;){if("\n"===r){let n,s=e;do{n=s+1,s=PlainValue.Node.endOfIndent(a,n)}while("\n"===a[s]);const r=s-(n+this.indent),l=t.type===PlainValue.Type.SEQ_ITEM&&t.context.atLineStart;if("#"!==a[s]&&!PlainValue.Node.nextNodeIsIndented(a[s],r,!l))break;this.atLineStart=!0,this.lineStart=n,i=!1,e=s}else if(r===PlainValue.Char.COMMENT){const n=PlainValue.Node.endOfLine(a,e+1);s.push(new PlainValue.Range(e,n)),e=n}else{let n=PlainValue.Node.endOfIdentifier(a,e+1);r===PlainValue.Char.TAG&&","===a[n]&&/^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(a.slice(e+1,n+13))&&(n=PlainValue.Node.endOfIdentifier(a,n+5)),s.push(new PlainValue.Range(e,n)),i=!0,e=PlainValue.Node.endOfWhiteSpace(a,n)}r=a[e]}i&&":"===r&&PlainValue.Node.atBlank(a,e+1,!0)&&(e-=1);return{props:s,type:ParseContext.parseType(a,e,n),valueStart:e}}}function parse(e){const n=[];-1!==e.indexOf("\r")&&(e=e.replace(/\r\n?/g,((e,t)=>(e.length>1&&n.push(t),"\n"))));const t=[];let a=0;do{const n=new Document,s=new ParseContext({src:e});a=n.parse(s,a),t.push(n)}while(a<e.length);return t.setOrigRanges=()=>{if(0===n.length)return!1;for(let e=1;e<n.length;++e)n[e]-=e;let e=0;for(let a=0;a<t.length;++a)e=t[a].setOrigRanges(n,e);return n.splice(0,n.length),!0},t.toString=()=>t.join("...\n"),t}exports.parse=parse;
